JNI(Java Native Interface)用途Java层调用C/C++层代码。总的流程分为以下三步
* Java层`System.loadLibrary("native-lib");`, native关键字声明本地方法
* 编译产生头文件， 根据头文件.h完成具体实现.c文件，将.c编译成dll或者so文件
* 将dll放置lib正式运行

```
 gcc -D __int64="long long" -I /cygdrive/d/Program\ Files/Java/jdk1.8.0_92/include -I /cygdrive/d/Program\ Files/Java/jdk1.8.0_92/include/win32/ -shared -o Main.dll Main.c


 --------------
 /cygdrive/d/Program Files/Java/jdk1.8.0_92/include/win32/jni_md.h:34:9: 错误：未知的类型名‘__int64’
 typedef __int64 jlong;
添加 `-D __int64="long long"`选项
```

javah生成的.h头文件只有形参类型没有形参可能会引起报错 手动添加形参
```
JNIEXPORT void JNICALL Java_Main_sayHello(JNIEnv * env, jobject cla) {
    printf("Hello World! c code \n");
    return;
}
```

gcc/g++, cmake, make, gdb


-Dsun.java2d.d3d=false



```
Process finished with exit code -1073741819 (0xC0000005)

```


```
gcc -D __int64="long long" -c -I /cygdrive/d/Program\ Files/Java/jdk1.8.0_92/include/ -I /cygdrive/d/Program\ Files/Java/jdk1.8.0_92/include/win32/ Main.c

gcc -Wl,--add-stdcall-alias -shared -o Main.dll Main.o

gcc -D __int64="long long" -I /cygdrive/d/Program\ Files/Java/jdk1.8.0_92/include -I /cygdrive/d/Program\ Files/Java/jdk1.8.0_92/include/win32/ -shared -o Main.dll Main.c

```

编译cpp文件执行
```
$ gcc -D __int64="long long" -I /cygdrive/d/Program\ Files/Java/jdk1.8.0_92/include -I /cygdrive/d/Program\ Files/Java/jdk1.8.0_92/include/win32/ -shared -o native-lib.dll native-lib.cpp

```
出现错误提示
```
/tmp/cct5NaqB.o:native-lib.cpp:(.text+0x1e)：对‘std::allocator<char>::allocator()’未定义的引用
/tmp/cct5NaqB.o:native-lib.cpp:(.text+0x1e):  截断重寻址至相符: R_X86_64_PC32 针对未定义的符号 std::allocator<char>::allocator()
/tmp/cct5NaqB.o:native-lib.cpp:(.text+0x38)：对‘std::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(char const*, std::allocator<char> const&)’未定义的引用
.....
/tmp/cct5NaqB.o:native-lib.cpp:(.xdata+0xc)：对‘__gxx_personality_seh0’未定义的引用
/tmp/cct5NaqB.o:native-lib.cpp:(.xdata+0xc):  截断重寻址至相符: rva32 针对未定义的符号 __gxx_personality_seh0
collect2: 错误：ld 返回 1
```

把换成g++执行即可
```
$ g++ -D __int64="long long" -I /cygdrive/d/Program\ Files/Java/jdk1.8.0_92/include -I /cygdrive/d/Program\ Files/Java/jdk1.8.0_92/include/win32/ -shared -o native-lib.dll native-lib.cpp

```

一段可用的cpp源码如下：
```
#include <jni.h>
#include <string>

extern "C" JNIEXPORT jstring

JNICALL
Java_com_seeksky_jnidemo_Main_stringFromJNI(
        JNIEnv *env,
        jobject /* this */) {
    std::string hello = "Hello from C++";
    return env->NewStringUTF(hello.c_str());
}

extern "C" JNIEXPORT jint 
JNICALL 
Java_com_seeksky_jnidemo_Main_sort(JNIEnv *env, jclass cls, jint var) {
    int returnValue = 200;
    return 200000;
}
```

编译产生dll文件的指令如下(cygwin+g++)
```
g++ -D __int64="long long" -I /cygdrive/d/Program\ Files/Java/jdk1.8.0_92/include -I /cygdrive/d/Program\ Files/Java/jdk1.8.0_92/include/win32/ -shared -o native-lib.dll native-lib.cpp
```

* `-D __int64="long long"`是为了解决Cygwin中可能出现的未知的类型名‘__int64’问题
* 两个-I指向了jdk中jni.h和jni_md.h的路径
* `-shared` 代表要生成dll动态库文件dll
* `-o` 指定生成的动态库名称
* 最后的`native-lib.cpp`是源文件。

以上是通过Android Studio的NDK帮助下测试出来可以正常运行Cpp代码和dll，生成的dll可以在Intellij Idea构建的项目中正常运行，下面尝试手动一步步生成相关代码。

传统的JNI的开发过程是：
* Java层定义包含native修饰的方法，build项目或者`javac`编译该类产生Class文件
* `javah`处理Class文件产生.h的C的头文件。
* 拷贝产生的头文件中的方法声明至新建的.c文件，实现具体的逻辑。
* 编译.c文件产生dll或者so
* 将产生的dll或者so存放至libs，项目运行时引用该库

新建项目jnidemo，位于`E:\MyCode\JavaCode\jnidemo`目录。`Main.java`代码如下：
```
package com.seeksky.jnidemo;

public class Main {
    static {
        System.loadLibrary("native-lib");
    }
    public static native int sort(int count);
    public static void main(String[] args) {
        System.out.println("native before");
        System.out.println(Main.sort(4));
        System.out.println("native after");
    }
}
```

`System.loadLibrary`用于加载C库，static修饰的代码块可以保证只会被加载一次。


产生的.h头文件
```
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class com_seeksky_jnidemo_Main */

#ifndef _Included_com_seeksky_jnidemo_Main
#define _Included_com_seeksky_jnidemo_Main
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     com_seeksky_jnidemo_Main
 * Method:    sort
 * Signature: (I)I
 */
JNIEXPORT jint JNICALL Java_com_seeksky_jnidemo_Main_sort
  (JNIEnv *, jclass, jint);

#ifdef __cplusplus
}
#endif
#endif
```

新建com_seeksky_jnidemo_Main.c(名称随意)文件实现逻辑，内容如下：
```
#include <stdio.h>
#include <jni.h>
#include "com_seeksky_jnidemo_Main.h"

JNIEXPORT jint JNICALL Java_com_seeksky_jnidemo_Main_sort(JNIEnv *env, jclass cls, jint var) {
    int count = 200;
    return count;
}
```

编译.c文件产生native-lib.dll。
```
gcc -D __int64="long long" -I /cygdrive/d/Program\ Files/Java/jdk1.8.0_92/include -I /cygdrive/d/Program\ Files/Java/jdk1.8.0_92/include/win32/ -shared -o native-lib.dll com_seeksky_jnidemo_Main.c
```

拷贝native-lib.dll至lib，之后配置项目的运行参数，加上` -Djava.library.path=xxx`xxx是lib所在的路径。

win10运行项目遭遇错误

> Process finished with exit code -1073741819 (0xC0000005)

这个问题在我用IntellijIdea写JNI的例子时一直出现，导致JNI例子一直没有调用成功过后来在Android Studio的搭配NDK+CMake写出来的例子没有问题。

先说结论。代码没有问题。

0xC0000005 错误码表示访问冲突。

> https://blog.csdn.net/tz_zs/article/details/77427842
> https://blog.csdn.net/River_Continent/article/details/78891674


问题分析：
以“Java 错误码 0xC0000005”为关键字搜索得到信息
* 可能是权限问题UAC鉴权失败，以右键管理员启动Idea运行项目依旧如此，解决失败
* https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/crashes001.html，

总结来说就是：Java调用dll或so库中的方法。
那Android上面的JNI开发来说，发展上有那么几个过程。
* 纯粹的JNI开发，命令行生成头文件，实现逻辑，gcc/g++编译产生dll(so)文件
* ndk阶段，配合Android.mk和Application.mk完成编译阶段产生dll文件
* NDK+CMake阶段。摒弃Android.mk的方式，使用CMakeLists.txt完成配置。


把一个普通的Android项目转化为支持C的项目需要如下几部
1. alt+enter带native标记的方法快速生成c文件，生成的文件应该在新生成的jni目录下面，java同层目录新建cpp文件夹，将生成的c文件复制cpp，删除jni目录，这样别的native方法，alt+enter时会直接在cpp下的c文件生成方法
2. 模块级别的build.gradle同级目录新建CMakeLists.txt
```
# For more information about using CMake with Android Studio, read the
# documentation: https://d.android.com/studio/projects/add-native-code.html

# Sets the minimum version of CMake required to build the native library.

cmake_minimum_required(VERSION 3.4.1)

# Creates and names a library, sets it as either STATIC
# or SHARED, and provides the relative paths to its source code.
# You can define multiple libraries, and CMake builds them for you.
# Gradle automatically packages shared libraries with your APK.

add_library( # Sets the name of the library.
             native-sort-lib

             # Sets the library as a shared library.
             SHARED

             # Provides a relative path to your source file(s).
             src/main/cpp/com_example_administrator_testsdk_MainActivity_getNativeInt.cpp)

# Searches for a specified prebuilt library and stores the path as a
# variable. Because CMake includes system libraries in the search path by
# default, you only need to specify the name of the public NDK library
# you want to add. CMake verifies that the library exists before
# completing its build.

find_library( # Sets the name of the path variable.
              log-lib

              # Specifies the name of the NDK library that
              # you want CMake to locate.
              log )

# Specifies libraries CMake should link to your target library. You
# can link multiple libraries, such as libraries you define in this
# build script, prebuilt third-party libraries, or system libraries.

target_link_libraries( # Specifies the target library.
                       native-sort-lib

                       # Links the target library to the log library
                       # included in the NDK.
                       ${log-lib} )
```

3. build.gradle中新增
```
android {
    .....
    externalNativeBuild {
        cmake {
            path 'CMakeLists.txt'
        }
    }
    .....
}
```
同步gradle。


# 参考资料
1. [Android NDK开发之旅(3)： 详解JNI数据类型与C/C++、Java之间的互调](https://blog.csdn.net/andrexpert/article/details/72851294)
2. [IntelliJ IDEA平台下JNI编程（一）—HelloWorld篇](https://blog.csdn.net/huachao1001/article/details/53906237)
3. []()