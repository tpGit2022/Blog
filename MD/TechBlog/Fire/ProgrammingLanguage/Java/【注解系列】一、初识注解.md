> In the Java computer programming language, an annotation is a form of syntactic metadata that can be added to Java source code. Classes, methods, variables, parameters and packages may be annotated. Unlike Javadoc tags, Java annotations can be reflective by means of being embedded in class files, which are generated by the compiler, and may be retained by the Java VM to be made retrievable at run-time. It is possible to create meta-annotations out of the existing ones in Java.


Android开发中注解很常见，如第三方库ButterKnife的@BindView等都是Annotation(注解，有的地方也将其翻译为注释)，基本上Android中的注解和annotationProcessor(注解处理器)紧密相关，本文先介绍注解。`java.lang.annotation`。平常见到的`@Override`,`@Deprecated`，注解定义的方式如下：
```
//使用@interface修饰
public @interface  SomethingName {
}
```
本质上来说注解定义的类型是接口。
什么是注解（Annotation）：

　　Annotation（注解）就是Java提供了一种元程序中的元素关联任何信息和着任何元数据（metadata）的途径和方法。Annotion(注解)是一个接口，程序可以通过反射来获取指定程序元素的Annotion对象，然后通过Annotion对象来获取注解里面的元数据。

　　Annotation(注解)是JDK5.0及以后版本引入的。它可以用于创建文档，跟踪代码中的依赖性，甚至执行基本编译时检查。从某些方面看，annotation就像修饰符一样被使用，并应用于包、类 型、构造方法、方法、成员变量、参数、本地变量的声明中。这些信息被存储在Annotation的“name=value”结构对中。

　　Annotation的成员在Annotation类型中以无参数的方法的形式被声明。其方法名和返回值定义了该成员的名字和类型。在此有一个特定的默认语法：允许声明任何Annotation成员的默认值：一个Annotation可以将name=value对作为没有定义默认值的Annotation成员的值，当然也可以使用name=value对来覆盖其它成员默认值。这一点有些近似类的继承特性，父类的构造函数可以作为子类的默认构造函数，但是也可以被子类覆盖。

　　Annotation能被用来为某个程序元素（类、方法、成员变量等）关联任何的信息。需要注意的是，这里存在着一个基本的规则：Annotation不能影响程序代码的执行，无论增加、删除 Annotation，代码都始终如一的执行。另外，尽管一些annotation通过java的反射api方法在运行时被访问，而java语言解释器在工作时忽略了这些annotation。正是由于java虚拟机忽略了Annotation，导致了annotation类型在代码中是“不起作用”的； 只有通过某种配套的工具才会对annotation类型中的信息进行访问和处理。本文中将涵盖标准的Annotation和meta-annotation类型，陪伴这些annotation类型的工具是java编译器（当然要以某种特殊的方式处理它们）。

什么是metadata（元数据）：

　　元数据从metadata一词译来，就是“关于数据的数据”的意思。
　　元数据的功能作用有很多，比如：你可能用过Javadoc的注释自动生成文档。这就是元数据功能的一种。总的来说，元数据可以用来创建文档，跟踪代码的依赖性，执行编译时格式检查，代替已有的配置文件。如果要对于元数据的作用进行分类，目前还没有明确的定义，不过我们可以根据它所起的作用，大致可分为三类： 
　　　　1. 编写文档：通过代码里标识的元数据生成文档
　　　　2. 代码分析：通过代码里标识的元数据对代码进行分析
　　　　3. 编译检查：通过代码里标识的元数据让编译器能实现基本的编译检查
　　在Java中元数据以标签的形式存在于Java代码中，元数据标签的存在并不影响程序代码的编译和执行，它只是被用来生成其它的文件或针在运行时知道被运行代码的描述信息。
　　综上所述：
　　　　第一，元数据以标签的形式存在于Java代码中。
　　　　第二，元数据描述的信息是类型安全的，即元数据内部的字段都是有明确类型的。
　　　　第三，元数据需要编译器之外的工具额外的处理用来生成其它的程序部件。
　　　　第四，元数据可以只存在于Java源代码级别，也可以存在于编译之后的Class文件内部。

 Annotation和Annotation类型：

　　Annotation：

　　Annotation使用了在java5.0所带来的新语法，它的行为十分类似public、final这样的修饰符。每个Annotation具有一个名字和成员个数>=0。每个Annotation的成员具有被称为name=value对的名字和值（就像javabean一样），name=value装载了Annotation的信息。

　　Annotation类型：

　　Annotation类型定义了Annotation的名字、类型、成员默认值。一个Annotation类型可以说是一个特殊的java接口，它的成员变量是受限制的，而声明Annotation类型时需要使用新语法。当我们通过java反射api访问Annotation时，返回值将是一个实现了该 annotation类型接口的对象，通过访问这个对象我们能方便的访问到其Annotation成员。后面的章节将提到在java5.0的 java.lang包里包含的3个标准Annotation类型。

注解的分类：

　　根据注解参数的个数，我们可以将注解分为三类：
　　　　1.标记注解:一个没有成员定义的Annotation类型被称为标记注解。这种Annotation类型仅使用自身的存在与否来为我们提供信息。比如后面的系统注解@Override;
　　　　2.单值注解
　　　　3.完整注解　　

　　根据注解使用方法和用途，我们可以将Annotation分为三类：
　　　　1.JDK内置系统注解
　　　　2.元注解
　　　　3.自定义注解
***元注解***  
元注解负责注解其他注解，元注解有四个`@Target,@Retention,@Documented,@Inherited`,四个元注解从不同层面做出限制。  
元注解的作用就是负责注解其他注解。Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。Java5.0定义的元注解：

**@Target**  
@Target说说明了Annotation所修饰的对象范围，Annotation可被用于pacakge,type(类，接口，枚举，Annotation类型),类型成员(方法，构造方法，成员变量，枚举值),方法参数和本地变量.通过@Target可以更清晰的限定注解可用于的目标。
**作用：用于描述注解的使用范围(即：被描述的注解可以用在什么地方)**  
常见代码如下：
```
@Target(ElementType.FIELD)
public @interface CustomAn {
}
//或者
@Target({ElementType.FIELD,ElementType.CONSTRUCTOR})
public @interface CustomAn {
}
//或者
//不接任何ElementType则代表该注解可以修饰任何可修饰的东西
public @interface CustomAn {
}
```
@Target可接受参数，ElementType是枚举类型，包含的值如下：

| 名称 |　作用  |
|:--:|:--:|
| TYPE | 作用于类class，接口(包括注解Annotation),枚举类型 |
|　FIELD | 作用于字段(包括枚举常量) |
|　METHOD | 作用于非构造方法即普通方法，类方法 |
| PARAMETER | 作用于参数，多指方法的参数 |
| CONSTRUCTOR | 作用于构造方法 |
| LOCAL_VARIABLE | 作用于局部变量 | 
| ANNOTATION_TYPE | 作用于注解类型 |
| PACKAGE | 包 | 
| TYPE_PARAMETER | java1.8新增的且为隐藏 | 
| TYPE_USE | java1.8新增的且为隐藏 |

可用于@Target的有`@CONSTRUCTOR,@FIELD,@ANNOTATION_TYPE,@LOCAL_VARIABLE,@METHOD,@PACKAGE,@TYPE` 

**@Retention**  
@Retention定义了该注解被保留的时间长短，某些Annotation仅出现在源代码中，而被编译器丢弃；而另一些却被编译在class文件中；编译在class文件中的Annotation可能会被虚拟机忽略，而另一些在class被装载时将被读取（请注意并不影响class的执行，因为Annotation与class在使用上是被分离的）。使用这个meta-Annotation可以对 Annotation的“生命周期”限制。
**作用：表示需要在什么级别保存该注释信息，用于描述注解的生命周期（即：被描述的注解在什么范围内有效）** 
@Retention的取值有三种`RetentionPolicy.RUNTIME,RetentionPolicy.CLASS,RetentionPolicy.SOURCE`,同样RetentionPolicy是枚举类型，存在三个值CLASS,SOURCE,RUNTIME.与@Target只能接受三个值中的一个。
```
@Target({ElementType.LOCAL_VARIABLE,ElementType.PACKAGE})
@Retention(RetentionPolicy.RUNTIME)
public @interface CustomAn {
}
```
**@Documented**  
　@Documented用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化。Documented是一个标记注解，没有成员。
```
@Target({ElementType.LOCAL_VARIABLE,ElementType.PACKAGE})
@Retention(RetentionPolicy.SOURCE)
@Documented
public @interface CustomAn {
}
```

**@Inherited**  
是一个标记注解,可被继承关系的映射到（子类获取父类的注解Annotation信息）

# 自定义注解
使用@interface自定义注解时，自动继承了`java.lang.annotation.Annotation`接口，由编译程序自动完成其他细节。在定义注解时，不能继承其它的注解或者接口。@interface用来声明一个注解，其中的每一个方法时间上是声明了一个配置参数，方法的名称就是参数的名称， 返回值的类型就是参数的类型（返回值只能是基本类型，Class,String,enum或者它们的数组)，可以通过default来声明参数的默认值。
***定义注解的格式***  
```
public @interface 注解名 { 定义体 }
```
***注解参数可支持的数据类型***  

1. 所有的基本类型(int,float,boolean,byte,double,char,long.short)
2. String类型
3. Class类型
4. enum类型
5. Annotation类型
6. 以上类型的数组

　定义了注解，并在需要的时候给相关类，类属性加上注解信息，如果没有响应的注解信息处理流程，注解可以说是没有实用价值。如何让注解真真的发挥作用，主要就在于注解处理方法，下一步我们将学习注解信息的获取和处理！

1. 通过@interface定义，注解名即自定义的注解名
2. 注解配置参数名为注解类的方法名
    1. 所有方法没有方法体，方法名即为属性名，没有参数没有修饰符，实际上只允许pulic 和abstract修饰符，默认为public，不允许抛出异常。
    2. 方法返回值只能是基本类型，String, Class, annotation, enumeration 或者是他们的一维数组，返回类型即为属性类型
    3. 若只有一个默认属性，建议直接使用value()函数表示，一个属性都没有表示该 Annotation 为 Mark Annotation
    4. 可以加default表示默认值，null不能作为成员的默认值(非基本类型的注解元素的值不可为null)
　如果没有用来读取注解的方法和工作，那么注解也就不会比注释更有用处了。使用注解的过程中，很重要的一部分就是创建于使用注解处理器。Java SE5扩展了反射机制的API，以帮助程序员快速的构造自定义注解处理器。

注解处理器类库(java.lang.reflect.AnnotatedElement)：

　　Java使用Annotation接口来代表程序元素前面的注解，该接口是所有Annotation类型的父接口。除此之外，Java在java.lang.reflect 包下新增了AnnotatedElement接口，该接口代表程序中可以接受注解的程序元素，该接口主要有如下几个实现类：

　　Class：类定义
　　Constructor：构造器定义
　　Field：累的成员变量定义
　　Method：类的方法定义
　　Package：类的包定义

　　java.lang.reflect 包下主要包含一些实现反射功能的工具类，实际上，java.lang.reflect 包所有提供的反射API扩充了读取运行时Annotation信息的能力。当一个Annotation类型被定义为运行时的Annotation后，该注解才能是运行时可见，当class文件被装载时被保存在class文件中的Annotation才会被虚拟机读取。
　　AnnotatedElement 接口是所有程序元素（Class、Method和Constructor）的父接口，所以程序通过反射获取了某个类的AnnotatedElement对象之后，程序就可以调用该对象的如下四个个方法来访问Annotation信息：

　　方法1：<T extends Annotation> T getAnnotation(Class<T> annotationClass): 返回改程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null。
　　方法2：Annotation[] getAnnotations():返回该程序元素上存在的所有注解。
　　方法3：boolean is AnnotationPresent(Class<?extends Annotation> annotationClass):判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false.
　　方法4：Annotation[] getDeclaredAnnotations()：返回直接存在于此元素上的所有注释。与此接口中的其他方法不同，该方法将忽略继承的注释。（如果没有注释直接存在于此元素上，则返回长度为零的一个数组。）该方法的调用者可以随意修改返回的数组；这不会对其他调用者返回的数组产生任何影响。
# 注意事项
1. ElementType的LOCAL_VARIABLEE的问题
    ElementType.LOCAL_VARIABLE是方法中的局部变量。无法通过反射检索局部变量，所以局部变量的注解不会保留在类文件或者运行时也就是说ElementType.LOCAL_VARIABLE只能用在RetentionPolicy.SOURCE情况下。
    http://www.iteye.com/topic/180240
    https://jcp.org/en/jsr/detail?id=308
2. ElementType的package的用法
    http://www.cnblogs.com/ycoe/archive/2009/09/26/1574565.html
3. javap -c classname
4. javadoc -d api xxx


#参考资料

1. [维基百科上的注解Annonation的介绍](https://en.wikipedia.org/wiki/Java_annotation)
2. [Oracle和注解相关的文档](https://docs.oracle.com/javase/tutorial/java/annotations/index.html)
3. [](http://www.java2s.com/Tutorial/Java/0020__Language/TheBuiltInAnnotations.htm)
4. [深入理解Java：注解（Annotation）基本概念](http://www.cnblogs.com/peida/archive/2013/04/23/3036035.html)
5. [深入理解Java：注解（Annotation）--注解处理器](http://www.cnblogs.com/peida/archive/2013/04/26/3038503.html)
