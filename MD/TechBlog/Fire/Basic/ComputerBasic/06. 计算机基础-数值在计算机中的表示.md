[TOC]


我们用正负号来区分正数和负数，而计算机只认识0和1，为了识别正负数我们将最高位设置为符号位，0表示正数，1表示负数。之所以出现原码，反码，补码概念是因为正负数之间的运算碰到的问题而产生的。


以 8 位为例 。
85 的二进制表示 `0101 0101`, -85 的二进制表示应该是 `1101 0101`。

85 的原码，反码，补码如下:
原码 `0101 0101` 反码 `0101 0101` 补码 `0101 0101`  
-85 的原码，反码，补码如下:
原码 `1101 0101` 反码 `1010 1010` 补码 `1010 1011`  

18 的二进制表示 `0001 0010`, -18 的二进制表示 `1001 0010`。  

18 的原码，反码，补码  
原码 `0001 0010` 反码 `0001 0010` 补码 `0001 0010`  

-18 的原码，反码，补码
原码 `1001 0010` 反码 `1110 1101` 补码 `1110 1110`  

# 原码


# 反码


# 补码

one's complement
补码 two's complement

正数，负数，0.
最高位表示符号位。假设最高位为8位。对于任意数N

原码：N >=0 原码为N的二进制表示，N < 0 原码为-N的二进制表示同时将最高位置1
反码：正数的反码是本身，负数的反码除符号位外按位取反
补码: 正数的补码是原码。负数的补码是反码+1

这样导致0有了两种+0和-0两种表示 `1000 0000` 和 `0000 0000`，为了合理利用空间人为规定 `1000 0000` 代表 `-2^7=128`

溢出问题。常说最高位是符号位，那最高位到底是多少位。在不同编程语言的不同类型中是不同的。以 Java 为例，Java中的数值类型有 `byte,short,char,int,long,float,double`。

`byte` 共8位
`short` 16位
`char` 16位

具体到了多少位就会有以下问题负数表示的范围会比正数多一位，取相反数的时候会出现数据的溢出。

运算产生的溢出。以8位为例。

127 + 1 = `0111 1111` + `0000 0001` --> `1000 0000` ---> -128

127 + -127 = `0111 1111` + `1000 0001` --> `0001 0000 0000` --> `0000 0000` --> 0

127 + -1 = `0111 1111` + `1111 1111` --> `0001 0111 1110` --> `0111 1110` --> 126

正数 128 的二进制表示是 `1000 0000`, 然而如果只有八位，最高位又需要表示那 128 仅用 8 位是表示不了的。

# 补码的运算

# 参考资料
1. [原码，反码，补码的深入理解与原理](https://blog.csdn.net/zhiwen_a/article/details/81192087)
2. [取模运算法则,异或运算法则](https://blog.csdn.net/github_35736728/article/details/79474903)